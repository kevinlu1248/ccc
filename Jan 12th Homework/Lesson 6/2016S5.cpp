#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 100010;
char a[2][N];
int n;
long long t;

// a % b = c   <=>  c = a - a/b
/*
5 3
01011
00011
10111
10100

a[t+1][i] = a[t][i-1] ^ a[t][i+1]

a[t+2][i] = a[t+1][i-2]^a[t+1][i] ^ a[t+1][i]^a[t+1][i+2]
          = a[t][i-2] ^ a[t][i+2]

a[t+3][i] = a[t+1][i-2] ^ a[t+1][i+2]
          = a[t][i-3]^a[t][i-1] ^ a[t][i+1]^a[t][i+3]

a[t+4][i] = a[t+2][i-2] ^ a[t+2][i+2]
          = a[t+1][i-3]^a[t+1][i-1] ^ a[t+1][i+1]^a[t+1][i+3]
          = a[t][i-4]^a[t][i-2] ^ a[t][i-2]^a[t][i] ^ a[t][i]^a[t][i+2] ^ a[t][i+2]^a[t+1][i+4]
          = a[t][i-4] ^ a[t][i+4]

a[t+p][i] = a[t][i-p] ^ a[t][i+p]   X

0:  00000000000000100000000000000
1:  00000000000001010000000000000
2:  00000000000010001000000000000
3:  00000000000101010100000000000
4:  00000000001000000010000000000
5:  00000000010100000101000000000
6:  00000000100010001000100000000
7:  00000001010101010101010000000
8:  00000010000000000000001000000
9:  00000101000000000000010100000
10: 00001000100000000000100010000
*/

/*
10 = 2^3 + 2^1
10 = 00001010

k = 2
 x = 00000100 (1<<k)
10&x==0说明10的二进制展开中没有x，即没有2^k
k = 3
 x = 00001000 (1<<k)
10&x==1说明10de二进制展开中有x，即会分解出2^3

10&(1<<k)!=0 <=> (10>>k)&1!=0 效果相同
10>>3:  00001
*/
int now;
void solve(int x){ // 对所有x是2^k的形式是正确的，对其他情况错误
    x %= n; // x in [0,n)
    for(int i=0;i<n;i++)
        a[!now][i] = (a[now][(i+x)%n] != a[now][(i-x+n)%n]) + '0';
    now = !now;
}
int main(){
    scanf("%d%lld", &n, &t);
    scanf("%s", a[now]);
    for(int k = 50; k >= 0; k--){ // 10^3 < 2^10, 10^15 < 2^50
        if((t >> k)&1LL){ // t&(1LL << k) !=0
            long long x = 1LL << k;
            //上述内容在判断t的二进制展开中是否存在x=2^k
            //如果存在，往后推x代
            //t = sum( 2^k ) = sum( x )
            //10 = 8 + 2
            //0 -> +2 -> +8 = 10
            solve(x);
        }
    }
    printf("\n");
    return 0;
}